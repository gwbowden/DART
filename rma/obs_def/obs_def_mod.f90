! DART software - Copyright 2004 - 2013 UCAR. This open source software is
! provided by UCAR, "as is", without charge, subject to all terms of use at
! http://www.image.ucar.edu/DAReS/DART/DART_download
!
! $Id: DEFAULT_obs_def_mod.F90 6256 2013-06-12 16:19:10Z thoar $

!----------------------------------------------------------------------
! WARNING!!  The file obs_def_mod.f90 is AUTOGENERATED by the
! 'preprocess' program.  Any changes made to this file will be
! overwritten when it is regenerated.  To make permanent changes
! in the code, edit DEFAULT_obs_def_mod.F90, or edit the
! observation specific obs_def_xxx_mod.f90 files.
!----------------------------------------------------------------------


!----------------------------------------------------------------------
!----------------------------------------------------------------------
! Any observation-specific modules which contain executable code to
! handle the interpolation and/or reading and writing of the obs will
! have the module code inserted here.  Then models only have to use
! the obs_def_mod module, and only include obs_def_mod.f90 in their
! path_names files.  To change the observation types/kinds, edit the
! model-specific 'input.nml' file and add or remove lines from the
! &preprocess_nml section, the 'input_files' list.
!
! Start of any user-defined executable module code
!----------------------------------------------------------------------

!---------------------------------------------------------------------------  
! Start of code inserted from ../../../obs_def/obs_def_1d_state_mod.f90
!---------------------------------------------------------------------------  
                                                                              
module obs_def_1d_state_mod

! This code currently does not require a namelist, but to add one search for
! the string 'NML' and comment in the code lines in the 4 marked sections.

use        types_mod, only : r8, missing_r8
use    utilities_mod, only : register_module, error_handler,               &
                             E_ERR, E_MSG, ascii_file_format !,            &
                             ! find_namelist_in_file, check_namelist_read, &
                             ! nmlfileunit, do_nml_file, do_nml_term
                             !! Routines only needed for namelist support. NML1
use     location_mod, only : location_type, set_location, get_location
use  assim_model_mod, only : interpolate, interpolate_distrib !HK
use   cov_cutoff_mod, only : comp_cov_factor
use data_structure_mod, only : ensemble_type

implicit none

! These are the required interfaces for an obs_def module.
public :: write_1d_integral, read_1d_integral, &
          interactive_1d_integral, get_expected_1d_integral, &
          set_1d_integral, get_expected_1d_integral_distrib

! Storage for the special information required for observations of this type
integer               :: num_1d_integral_obs = 0     ! current count of obs
integer               :: max_1d_integral_obs = 1000  ! allocation size limit
real(r8), allocatable :: half_width(:)         ! metadata storage
integer,  allocatable :: num_points(:)         ! ditto
integer,  allocatable :: localization_type(:)  ! ditto


! Set to .true. to get debugging output
logical :: debug = .false.


! version controlled file description for error handling, do not edit
character(len=256), parameter :: source   = &
   "$URL: https://proxy.subversion.ucar.edu/DAReS/DART/branches/rma/obs_def/obs_def_1d_state_mod.f90 $"
character(len=32 ), parameter :: revision = "$Revision: 6256 $"
character(len=128), parameter :: revdate  = "$Date: 2013-06-12 10:19:10 -0600 (Wed, 12 Jun 2013) $"

logical, save :: module_initialized = .false.

!! To enable the namelist, comment this in.  NML2
!namelist /one_d_integral_nml/  debug, max_1d_integral_obs

contains

!----------------------------------------------------------------------

subroutine initialize_module

! Anything in this routine is executed exactly once.  It could be used
! to read in a namelist, precompute values needed later, etc.
! Currently this routine logs the version information and allocates
! space for the metadata arrays.

!! Only needed if you've commented in the namelist code.  NML3
!integer :: iunit, io

! Execute the code here just once
if (module_initialized) return

! Logs version information to file.
call register_module(source, revision, revdate)

! To enable a namelist (e.g to set max number of obs, or to turn
! on the debug messages at run time, or whatever) search for 'NML'
! and comment in the 4 code sections marked with that string.  NML4
!
!! Read the namelist input
!call find_namelist_in_file("input.nml", "one_d_integral_nml", iunit)
!read(iunit, nml = one_d_integral_nml, iostat = io)
!call check_namelist_read(iunit, io, "one_d_integral_nml")
!
!! Record the namelist values used for the run
!if (do_nml_file()) write(nmlfileunit, nml=one_d_integral_nml)
!if (do_nml_term()) write(     *     , nml=one_d_integral_nml)

! Allocate space for the metadata
allocate(half_width(max_1d_integral_obs),  &
         num_points(max_1d_integral_obs),  &
         localization_type(max_1d_integral_obs))

module_initialized = .true.
if(debug) print*, 'module initialized'

end subroutine initialize_module

!----------------------------------------------------------------------------

subroutine write_1d_integral(igrkey, ifile, fform)
 integer,          intent(in)           :: igrkey, ifile
 character(len=*), intent(in), optional :: fform

! Write out the additional data associated with this observation.
! The obs is identified by the incoming 'key' argument.

logical :: is_ascii

if ( .not. module_initialized ) call initialize_module

! Make sure key value is within valid range -- it will be used as an index below.
call check_valid_key(igrkey, 'GIVEN', 'write_1d_integral')

is_ascii = ascii_file_format(fform)
if(debug) print*, 'write_1d_integral: ascii format = ', is_ascii

! Write out the half_width, num_points, and localization_type for each
! observation embedded in the observation.  The old key is written out
! for tracking/debug use if needed.

if (is_ascii) then
   write(ifile, *) half_width(igrkey), num_points(igrkey), localization_type(igrkey)
   write(ifile, *) igrkey
else
   write(ifile)    half_width(igrkey), num_points(igrkey), localization_type(igrkey)
   write(ifile)    igrkey
endif
if(debug) print*, 'writing out metadata for 1D integral obs ', igrkey
if(debug) print*, 'metadata values are: ', half_width(igrkey), num_points(igrkey), localization_type(igrkey)

end subroutine write_1d_integral

!----------------------------------------------------------------------

subroutine read_1d_integral(igrkey, ifile, fform)
 integer,          intent(out)          :: igrkey
 integer,          intent(in)           :: ifile
 character(len=*), intent(in), optional :: fform

! Read in the additional data associated with this observation.
! The key value in the file will be read and then discarded, and a new key
! will be generated based on the next available index in the metadata arrays.
! Notice that key is intent(out) here, not (in) as in some other routines.

logical            :: is_ascii
integer            :: ignored_igrkey

if ( .not. module_initialized ) call initialize_module

! Increment the counter so all key values are unique
num_1d_integral_obs = num_1d_integral_obs + 1

! Set the return value for the key, and use it as the index below
igrkey = num_1d_integral_obs

! Make sure key is within valid range
call check_valid_key(igrkey, 'GENERATED', 'read_1d_integral')

is_ascii = ascii_file_format(fform)
if(debug) print*, 'read_1d_integral: ascii format = ', is_ascii

! Read in the additional metadata for this observation, and discard the old key.
if (is_ascii) then
   read(ifile, *) half_width(igrkey), num_points(igrkey), localization_type(igrkey)
   read(ifile, *) ignored_igrkey
else
   read(ifile)    half_width(igrkey), num_points(igrkey), localization_type(igrkey)
   read(ifile)    ignored_igrkey
endif
if(debug) print*, 'read in metadata for 1D integral obs ', igrkey
if(debug) print*, 'metadata values are: ', half_width(igrkey), num_points(igrkey), localization_type(igrkey)

if(debug) print *, 'ignoring old key', ignored_igrkey
if(debug) print *, 'return key set to ', igrkey

end subroutine read_1d_integral

!----------------------------------------------------------------------

subroutine interactive_1d_integral(igrkey)
 integer, intent(out) :: igrkey

! Initializes the specialized part of a 1d_integral observation.
! A new key will be generated based on the next available index
! in the metadata arrays.


if ( .not. module_initialized ) call initialize_module

! Increment the counter so all key values are unique
num_1d_integral_obs = num_1d_integral_obs + 1

! Set the return value for the key, and use it as the index below
igrkey = num_1d_integral_obs

! Make sure key is within valid range
call check_valid_key(igrkey, 'GENERATED', 'interactive_1d_integral')

! Prompt for input for the three required metadata items
write(*, *) 'Creating an interactive_1d_integral observation'

write(*, *) 'Input half width of integral '
 read(*, *) half_width(igrkey)

write(*, *) 'Input the number of evaluation points (5-20 recommended) '
 read(*, *) num_points(igrkey)

write(*, *) 'Input localization type: 1=Gaspari-Cohn; 2=Boxcar; 3=Ramped Boxcar'
 read(*, *) localization_type(igrkey)

if(debug) print *, 'return key set to ', igrkey

end subroutine interactive_1d_integral

!----------------------------------------------------------------------

subroutine get_expected_1d_integral(state, location, igrkey, val, istatus)
 real(r8),            intent(in)  :: state(:)
 type(location_type), intent(in)  :: location
 integer,             intent(in)  :: igrkey
 real(r8),            intent(out) :: val
 integer,             intent(out) :: istatus

! The forward operator interface for this type of observation.  It is
! called with a state vector, a location, and a key to identify which
! observation is being processed.  The return 'val' is the expected
! observation value, and istatus is the return code.  0 is ok,
! > 0 signals an error, and < 0 values are reserved for system use.
! The call to 'interpolate()' below calls the forward operator in
! whatever model this code has been compiled with.

type(location_type) :: location2
integer             :: i
real(r8)            :: range, loc, bottom, dx, x, sum, dist, weight, weight_sum

if ( .not. module_initialized ) call initialize_module

! Make sure key is within valid range
call check_valid_key(igrkey, 'GIVEN', 'get_expected_1d_integral')

! Figure out the total range of the integrated funtion (1 is max)
range = 4.0_r8 * half_width(igrkey)
if(range > 1.0_r8) range = 1.0_r8
if(debug) print*, 'range is ', range

! Get the location value
loc = get_location(location)
if(debug) print*, 'loc base is ', loc

! Compute the bottom and top of the range
bottom = loc - range / 2.0_r8
if(bottom < 0.0_r8) bottom = bottom + 1.0_r8
if(debug) print*, 'bottom is ', bottom

! Next figure out where to put all the points
dx = range / (num_points(igrkey) - 1)
if(debug) print*, 'dx is ', dx

! Loop to compute the value at each point, then multiply by localization
! to get weighted integral
sum = 0.0_r8
weight_sum = 0.0_r8
do i = 1, num_points(igrkey)
   x = bottom + (i - 1) * dx
   if(x > 1.0_r8) x = x - 1.0_r8
if(debug) print*, 'location for int ', i, 'is ', x
   location2 = set_location(x)
   call interpolate(state, location2, 1, val, istatus)
if(debug) print*, 'model forward operator for ', i, ' returns ', val
   if (istatus /= 0) then
if(debug) print*, 'forward operator returned error, returning'
      val = missing_r8
      return
   endif
   dist = abs(loc - x)
   if(dist > 0.5_r8) dist = 1.0_r8 - dist
if(debug) print*, 'dist ', i, dist
   weight = comp_cov_factor(dist, half_width(igrkey), &
      localization_override = localization_type(igrkey))
if(debug) print*, 'weight ', i, weight
   sum = sum + weight * val
   weight_sum = weight_sum + weight
end do

val = sum / weight_sum

if(debug) print*, 'get_expected_1d_integral key is ', igrkey
if(debug) print*, 'metadata values are: ', half_width(igrkey), num_points(igrkey), localization_type(igrkey)
if(debug) print*, 'return value for forward operator is ', val
if(debug) print*, 'return status (0 good; >0 error; <0 reserved for system use) is ', istatus

end subroutine get_expected_1d_integral

!----------------------------------------------------------------------

subroutine get_expected_1d_integral_distrib(location, igrkey, expected_obs, istatus, state_ens_handle, win)
type(location_type), intent(in)  :: location
integer,             intent(in)  :: igrkey
real(r8),            intent(out) :: expected_obs(:)
integer,             intent(out) :: istatus
integer,             intent(in)  :: win !< mpi communication window
type(ensemble_type),  intent(in) :: state_ens_handle


! The forward operator interface for this type of observation.  It is
! called with a state vector, a location, and a key to identify which
! observation is being processed.  The return 'val' is the expected
! observation value, and istatus is the return code.  0 is ok,
! > 0 signals an error, and < 0 values are reserved for system use.
! The call to 'interpolate()' below calls the forward operator in
! whatever model this code has been compiled with.

type(location_type) :: location2
integer             :: i, j
real(r8)            :: range, loc, bottom, dx, x, dist !sum, dist, weight, weight_sum
real(r8), allocatable  :: sum(:), weight(:), weight_sum(:)

if ( .not. module_initialized ) call initialize_module

! Make sure key is within valid range
call check_valid_key(igrkey, 'GIVEN', 'get_expected_1d_integral')

allocate(sum(state_ens_handle%num_copies), weight(state_ens_handle%num_copies), &
   weight_sum(state_ens_handle%num_copies))


! Figure out the total range of the integrated funtion (1 is max)
range = 4.0_r8 * half_width(igrkey)
if(range > 1.0_r8) range = 1.0_r8
if(debug) print*, 'range is ', range

! Get the location value
loc = get_location(location)
if(debug) print*, 'loc base is ', loc

! Compute the bottom and top of the range
bottom = loc - range / 2.0_r8
if(bottom < 0.0_r8) bottom = bottom + 1.0_r8
if(debug) print*, 'bottom is ', bottom

! Next figure out where to put all the points
dx = range / (num_points(igrkey) - 1)
if(debug) print*, 'dx is ', dx

! Loop to compute the value at each point, then multiply by localization
! to get weighted integral
sum(:) = 0.0_r8
weight_sum(:) = 0.0_r8
do i = 1, num_points(igrkey)

   x = bottom + (i - 1) * dx
   if(x > 1.0_r8) x = x - 1.0_r8
   if(debug) print*, 'location for int ', i, 'is ', x
   location2 = set_location(x)
   call interpolate_distrib(location2, 1, istatus, expected_obs, state_ens_handle, win)

   if(debug) print*, 'model forward operator for ', i, ' returns ', expected_obs
   if (istatus /= 0) then
      if(debug) print*, 'forward operator returned error, returning'
      expected_obs(:) = missing_r8
      return
   endif
   dist = abs(loc - x)
   if(dist > 0.5_r8) dist = 1.0_r8 - dist
   if(debug) print*, 'dist ', i, dist

   ! loop for each copy
   do j = 1, state_ens_handle%num_copies

      weight(j) = comp_cov_factor(dist, half_width(igrkey), &
      localization_override = localization_type(igrkey))
      if(debug) print*, 'weight ', i, weight(j)
      sum(j) = sum(j) + weight(j) * expected_obs(j)
      weight_sum(j) = weight_sum(j) + weight(j)

   end do

enddo

expected_obs = sum / weight_sum

deallocate(sum, weight, weight_sum)

if(debug) print*, 'get_expected_1d_integral key is ', igrkey
if(debug) print*, 'metadata values are: ', half_width(igrkey), num_points(igrkey), localization_type(igrkey)
if(debug) print*, 'return value for forward operator is ', expected_obs
if(debug) print*, 'return status (0 good; >0 error; <0 reserved for system use) is ', istatus

end subroutine get_expected_1d_integral_distrib


!----------------------------------------------------------------------

subroutine set_1d_integral(integral_half_width, num_eval_pts, localize_type, igrkey, istatus)

! inputs are: half width of integral
!             the number of evaluation points (5-20 recommended)
!             localization type: 1=Gaspari-Cohn; 2=Boxcar; 3=Ramped Boxcar

 real(r8), intent(in)  :: integral_half_width
 integer,  intent(in)  :: num_eval_pts
 integer,  intent(in)  :: localize_type
 integer,  intent(out) :: igrkey
 integer,  intent(out) :: istatus

! Available to be called by a program creating these types of observations.
! Notice that igrkey is intent(out) here, not (in) as in some other routines.
! Sets the additional metadata for this obs, increments the key, and returns
! the new value.  This key value should be set in the obs_def derived type by
! calling set_obs_def_key().   Notice that this is different from the main
! observation key, which all observation entries have.  This key is specific
! to this observation type and is used to index into the metadata for only
! this type of obs.

if ( .not. module_initialized ) call initialize_module

! Increment the counter so all key values are unique
num_1d_integral_obs = num_1d_integral_obs + 1

! Set the return value for the key, and use it as the index below
igrkey = num_1d_integral_obs

! Make sure key is within valid range
call check_valid_key(igrkey, 'GENERATED', 'set_1d_integral')

! Set the corresponding values in the module global arrays
half_width(igrkey) = integral_half_width
num_points(igrkey) = num_eval_pts
localization_type(igrkey) = localize_type

istatus = 0

if(debug) print*, 'setting metadata for 1D integral obs ', igrkey
if(debug) print*, 'metadata values are: ', half_width(igrkey), num_points(igrkey), localization_type(igrkey)

if(debug) print*, 'return key set to ', igrkey
if(debug) print*, 'return status (0 good; >0 error; <0 reserved for system use) is ', istatus

end subroutine set_1d_integral

!----------------------------------------------------------------------

subroutine check_valid_key(igrkey, what, fromwhere)
 integer, intent(in)          :: igrkey
 character(len=*), intent(in) :: what, fromwhere

! Internal subroutine that verifies that we haven't incremented the key value
! past the size of the allocated space, or that a routine hasn't been called
! with a out-of-range key (which would indicate an internal error of some kind).
! If an error is found, an fatal message is printed and this routine doesn't return.
! The 'what' argument is either 'GIVEN' for a key value that's passed in from
! another routine; or 'GENERATED' for one we have just made and are planning to
! return to the caller.  The 'fromwhere' argument is the name of the calling
! subroutine so the error message can report where it was called from.

character(len=128) :: msgstring

if (igrkey <= 0 .or. igrkey > max_1d_integral_obs) then
   if (what == 'GENERATED' .and. igrkey > max_1d_integral_obs) then
      ! generating a new key and ran out of space
      write(msgstring, *)'Out of space, max_1d_integral_obs limit ',max_1d_integral_obs
      call error_handler(E_ERR,trim(fromwhere),msgstring,source,revision,revdate, &
                         text2='Increase value of max_1d_integral_obs in obs_def_1d_state_mod')
   else
      ! called with a bad key or a negative key generated somehow. "shouldn't happen".
      write(msgstring, *)'Key is ',igrkey,' must be between 1 and ',max_1d_integral_obs
      call error_handler(E_ERR,trim(fromwhere),msgstring,source,revision,revdate, &
                         text2='Internal error: Invalid key value in RAW_STATE_1D_INTEGRAL obs')
   endif
endif

end subroutine

!----------------------------------------------------------------------

end module obs_def_1d_state_mod

                                                                              
!---------------------------------------------------------------------------  
! End of code inserted from ../../../obs_def/obs_def_1d_state_mod.f90
!---------------------------------------------------------------------------  

!----------------------------------------------------------------------
! End of any user-defined executable module code
!----------------------------------------------------------------------
!----------------------------------------------------------------------

!----------------------------------------------------------------------
!----------------------------------------------------------------------
! Start of main obs_def_mod module code
!----------------------------------------------------------------------

module obs_def_mod

! Contains the basic parts of a module for defining and evaluating observation
! definitions. Can evaluate identity observations as is. The DART preprocess
! program is used to add in extra observation kinds at the indicated spots in
! the code.

use        types_mod, only : r8, missing_i, missing_r8, RAD2DEG
use    utilities_mod, only : register_module, error_handler, E_ERR, E_MSG, &
                             ascii_file_format
use     location_mod, only : location_type, read_location, write_location, &
                             interactive_location, set_location_missing
use time_manager_mod, only : time_type, read_time, write_time, set_time, &
                             set_time_missing, interactive_time
use  assim_model_mod, only : get_state_meta_data, interpolate, interpolate_distrib !HK
use     obs_kind_mod, only : assimilate_this_obs_kind, evaluate_this_obs_kind, &
                             max_obs_kinds, get_obs_kind_name, map_def_index, &
                             get_kind_from_menu

use data_structure_mod, only : ensemble_type

!----------------------------------------------------------------------
! This list is autogenerated by the 'preprocess' program.  To add types
! or kinds, edit the obs_def_xxx_mod.f90 files, and then add/remove them
! from the 'input_files' variable of the &preprocess_nml namelist
! in the model-specific work/input.nml file.
!
! Start of obs_def_xxx_mod specific types and kinds
!----------------------------------------------------------------------

!---------------------------------------------------------------------------  
                                                                              
use obs_kind_mod, only : RAW_STATE_VARIABLE
use obs_kind_mod, only : RAW_STATE_1D_INTEGRAL
                                                                              
use obs_kind_mod, only : KIND_RAW_STATE_VARIABLE
use obs_kind_mod, only : KIND_1D_INTEGRAL
                                                                              
!---------------------------------------------------------------------------  
                                                                              

!----------------------------------------------------------------------
! End of obs_def_xxx_mod specific types and kinds
!----------------------------------------------------------------------

!----------------------------------------------------------------------
! This section is autogenerated by the 'preprocess' program.
!
! Start of any obs_def_xxx_mod specific use statements
!----------------------------------------------------------------------

! If any observation types required specialized code, the module code
! will have been added above, and now a use statement will be generated
! here so the generic obs_def_mod has access to the code.

   use obs_def_1d_state_mod, only : write_1d_integral, read_1d_integral, &
                                     interactive_1d_integral, get_expected_1d_integral, &
                                     get_expected_1d_integral_distrib

!----------------------------------------------------------------------
! End of any obs_def_xxx_mod specific use statements
!----------------------------------------------------------------------


implicit none
private

interface assignment(=)
   module procedure copy_obs_def
end interface

public :: init_obs_def, get_obs_def_key, get_obs_def_location, get_obs_kind, &
   get_obs_def_time, get_obs_def_error_variance, set_obs_def_location, &
   set_obs_def_kind, set_obs_def_time, set_obs_def_error_variance, &
   set_obs_def_key, interactive_obs_def, write_obs_def, read_obs_def, &
   obs_def_type, get_expected_obs_from_def, destroy_obs_def, copy_obs_def, &
   assignment(=), get_obs_name, &
   get_expected_obs_from_def_distrib_state !HK

! version controlled file description for error handling, do not edit
character(len=256), parameter :: source   = &
   "$URL: https://proxy.subversion.ucar.edu/DAReS/DART/branches/rma/obs_def/DEFAULT_obs_def_mod.F90 $"
character(len=32 ), parameter :: revision = "$Revision: 6256 $"
character(len=128), parameter :: revdate  = "$Date: 2013-06-12 10:19:10 -0600 (Wed, 12 Jun 2013) $"

type obs_def_type
! In revision, obs_kind module is responsible for taking care of
! identity obs kinds, too
   private
   type(location_type)   :: location   ! center of mass, so to speak
   integer               :: kind
   type(time_type)       :: time
   real(r8)              :: error_variance
   integer               :: key        ! Used by specialized observation types
end type obs_def_type

logical, save :: module_initialized = .false.

contains

!----------------------------------------------------------------------------

subroutine initialize_module

call register_module(source, revision, revdate)
module_initialized = .true.

! Note that there is no namelist for this module now that
! obs_kind has been revised

end subroutine initialize_module


!----------------------------------------------------------------------------

subroutine init_obs_def(obs_def, location, kind, time, error_variance)
! Need to add additional component arguments as optionals as needed

! Constructor for an obs_def

type(obs_def_type), intent(out) :: obs_def
type(location_type), intent(in) :: location
integer,             intent(in) :: kind
type(time_type),     intent(in) :: time
real(r8),            intent(in) :: error_variance

if ( .not. module_initialized ) call initialize_module

obs_def%location = location
obs_def%kind = kind
obs_def%time = time
obs_def%error_variance = error_variance
! No key assigned for standard observation defs
obs_def%key = -1

end subroutine init_obs_def

!---------------------------------------------------------------------

subroutine copy_obs_def(obs_def1, obs_def2)

! Copy function to be overloaded with '='

type(obs_def_type), intent(out) :: obs_def1
type(obs_def_type), intent(in) :: obs_def2

if ( .not. module_initialized ) call initialize_module

obs_def1%location       = obs_def2%location
obs_def1%kind           = obs_def2%kind
obs_def1%time           = obs_def2%time
obs_def1%error_variance = obs_def2%error_variance
obs_def1%key            = obs_def2%key
!deallocate(obs_def1%platform_qc)
!allocate(obs_def1%platform_qc(size(obs_def2%platform_qc))
! Should this be pointer assignment or regular
!obs_def1%platform_qc >= or == obs_def2%platform_qc
!obs_def1%aperture = obs_def2%aperture

end subroutine copy_obs_def

!----------------------------------------------------------------------------

function get_obs_def_key(obs_def)

type(obs_def_type), intent(in) :: obs_def
integer                        :: get_obs_def_key

if ( .not. module_initialized ) call initialize_module

get_obs_def_key = obs_def%key

end function get_obs_def_key

!----------------------------------------------------------------------------

function get_obs_def_error_variance(obs_def)

type(obs_def_type), intent(in) :: obs_def
real(r8)                       :: get_obs_def_error_variance

if ( .not. module_initialized ) call initialize_module

get_obs_def_error_variance = obs_def%error_variance

end function get_obs_def_error_variance

!----------------------------------------------------------------------------

function get_obs_def_location(obs_def)

! Returns observation location.

type(location_type)            :: get_obs_def_location
type(obs_def_type), intent(in) :: obs_def

if ( .not. module_initialized ) call initialize_module

get_obs_def_location = obs_def%location

end function get_obs_def_location

!----------------------------------------------------------------------------

function get_obs_kind(obs_def)

! Returns observation kind

integer                        :: get_obs_kind
type(obs_def_type), intent(in) :: obs_def

if ( .not. module_initialized ) call initialize_module

get_obs_kind = obs_def%kind

end function get_obs_kind

!----------------------------------------------------------------------------

function get_obs_def_time(obs_def)

! Returns observation time

type(time_type)                :: get_obs_def_time
type(obs_def_type), intent(in) :: obs_def

if ( .not. module_initialized ) call initialize_module

get_obs_def_time = obs_def%time

end function get_obs_def_time

!----------------------------------------------------------------------------

function get_obs_name(obs_kind_ind)

! Returns observation name

integer, intent(in) :: obs_kind_ind
character(len = 32) :: get_obs_name

if ( .not. module_initialized ) call initialize_module

get_obs_name = get_obs_kind_name(obs_kind_ind)

end function get_obs_name

!----------------------------------------------------------------------------

subroutine set_obs_def_location(obs_def, location)

! Sets the location of an obs_def

type(obs_def_type), intent(inout) :: obs_def
type(location_type),   intent(in) :: location

if ( .not. module_initialized ) call initialize_module

obs_def%location = location

end subroutine set_obs_def_location

!----------------------------------------------------------------------------

subroutine set_obs_def_error_variance(obs_def, error_variance)

! Sets the error variance of an obs_def

type(obs_def_type), intent(inout) :: obs_def
real(r8), intent(in) :: error_variance

if ( .not. module_initialized ) call initialize_module

obs_def%error_variance = error_variance

end subroutine set_obs_def_error_variance

!----------------------------------------------------------------------------

subroutine set_obs_def_key(obs_def, key)

! Sets the key of an obs_def

type(obs_def_type), intent(inout) :: obs_def
integer,            intent(in)    :: key

if ( .not. module_initialized ) call initialize_module

obs_def%key = key

end subroutine set_obs_def_key

!----------------------------------------------------------------------------

subroutine set_obs_def_kind(obs_def, kind)

! Sets the kind of an obs_def

type(obs_def_type), intent(inout) :: obs_def
integer,               intent(in) :: kind

if ( .not. module_initialized ) call initialize_module

obs_def%kind = kind

end subroutine set_obs_def_kind

!----------------------------------------------------------------------------

subroutine set_obs_def_time(obs_def, time)

! Sets the time of an obs_def

type(obs_def_type), intent(inout) :: obs_def
type(time_type), intent(in) :: time

if ( .not. module_initialized ) call initialize_module

obs_def%time = time

end subroutine set_obs_def_time

!----------------------------------------------------------------------------

subroutine get_expected_obs_from_def(key, obs_def, obs_kind_ind, ens_index, &
   state, state_time, isprior, obs_val, istatus, assimilate_this_ob, evaluate_this_ob)

! Compute forward operator for a particular obs_def
integer,            intent(in)  :: key
type(obs_def_type), intent(in)  :: obs_def
integer,            intent(in)  :: obs_kind_ind, ens_index
real(r8),           intent(in)  :: state(:)
type(time_type),    intent(in)  :: state_time
logical,            intent(in)  :: isprior
real(r8),           intent(out) :: obs_val
integer,            intent(out) :: istatus
logical,            intent(out) :: assimilate_this_ob, evaluate_this_ob

type(location_type) :: location
type(time_type)     :: obs_time
integer             :: obs_key
real(r8)            :: error_var

! Load up the assimilate and evaluate status for this observation kind
assimilate_this_ob = assimilate_this_obs_kind(obs_kind_ind)
evaluate_this_ob = evaluate_this_obs_kind(obs_kind_ind)

! If not being assimilated or evaluated return with missing_r8 and istatus 0
if(assimilate_this_ob .or. evaluate_this_ob) then
   ! for speed, access directly instead of using accessor functions
   location  = obs_def%location
   obs_time  = obs_def%time
   obs_key   = obs_def%key
   error_var = obs_def%error_variance

   ! Compute the forward operator.  In spite of the variable name,
   ! obs_kind_ind is in fact a 'type' index number.  use the function
   ! get_obs_kind_var_type from the obs_kind_mod if you want to map
   ! from a specific type to a generic kind.  the third argument of
   ! a call to the 'interpolate()' function must be a kind index and
   ! not a type.  normally the preprocess program does this for you.
   select case(obs_kind_ind)

      ! arguments available to an obs_def forward operator code are:
      !   state        -- the entire model state vector
      !   state_time   -- the time of the state vector data
      !   ens_index    -- the ensemble number
      !   location     -- observation location
      !   obs_kind_ind -- the index of the observation specific type
      !   obs_time     -- the time of the observation
      !   error_var    -- the observation error variance
      !   isprior      -- true for prior eval; false for posterior
      !
      ! the routine must return values for:
      !   obs_val -- the computed forward operator value
      !   istatus -- return code: 0=ok, >0 is error, <0 reserved for system use
      !
      ! to call interpolate() directly, the arg list MUST BE:
      !  interpolate(state, location, KIND_xxx, obs_val, istatus)
      !
      ! the preprocess program generates lines like this automatically,
      ! and this matches the interfaces in each model_mod.f90 file.
      !
      ! CASE statements and algorithms for specific observation kinds are
      ! inserted here by the DART preprocess program.

         case(RAW_STATE_1D_INTEGRAL)
            call get_expected_1d_integral(state, location, obs_def%key, obs_val, istatus)
      case(RAW_STATE_VARIABLE)
         call interpolate(state, location, KIND_RAW_STATE_VARIABLE, obs_val, istatus)

      ! If the observation kind is not available, it is an error. The DART
      ! preprocess program should provide code for all available kinds.
      case DEFAULT
         call error_handler(E_ERR, 'get_expected_obs_from_def', &
            'Attempt to evaluate or assimilate undefined obs_kind type.', &
             source, revision, revdate)
   end select
else
   ! Not computing forward operator for this kind
   obs_val = missing_r8
   istatus = 0
endif

end subroutine get_expected_obs_from_def

!----------------------------------------------------------------------------

subroutine get_expected_obs_from_def_distrib_state(key, obs_def, obs_kind_ind, ens_index, &
   state_time, isprior, istatus, assimilate_this_ob, evaluate_this_ob,   &
   expected_obs, state_ens_handle, win)

! Compute forward operator for a particular obs_def
integer,            intent(in)  :: key
type(obs_def_type), intent(in)  :: obs_def
integer,            intent(in)  :: obs_kind_ind, ens_index
type(time_type),    intent(in)  :: state_time
logical,            intent(in)  :: isprior
integer,            intent(out) :: istatus
logical,            intent(out) :: assimilate_this_ob, evaluate_this_ob
real(r8),           intent(out) :: expected_obs(:)
type(ensemble_type),  intent(in) :: state_ens_handle
integer,            intent(in)  :: win !< mpi communication window

type(location_type) :: location
type(time_type)     :: obs_time
integer             :: obs_key
real(r8)            :: error_var

! Load up the assimilate and evaluate status for this observation kind
assimilate_this_ob = assimilate_this_obs_kind(obs_kind_ind)
evaluate_this_ob = evaluate_this_obs_kind(obs_kind_ind)

! If not being assimilated or evaluated return with missing_r8 and istatus 0
if(assimilate_this_ob .or. evaluate_this_ob) then
   ! for speed, access directly instead of using accessor functions
   location  = obs_def%location
   obs_time  = obs_def%time
   obs_key   = obs_def%key
   error_var = obs_def%error_variance

   ! Compute the forward operator.  In spite of the variable name,
   ! obs_kind_ind is in fact a 'type' index number.  use the function
   ! get_obs_kind_var_type from the obs_kind_mod if you want to map
   ! from a specific type to a generic kind.  the third argument of
   ! a call to the 'interpolate()' function must be a kind index and
   ! not a type.  normally the preprocess program does this for you.
   select case(obs_kind_ind)

      ! arguments available to an obs_def forward operator code are:
      !   state        -- the entire model state vector
      !   state_time   -- the time of the state vector data
      !   ens_index    -- the ensemble number
      !   location     -- observation location
      !   obs_kind_ind -- the index of the observation specific type
      !   obs_time     -- the time of the observation
      !   error_var    -- the observation error variance
      !   isprior      -- true for prior eval; false for posterior
      !
      ! the routine must return values for:
      !   obs_val -- the computed forward operator value
      !   istatus -- return code: 0=ok, >0 is error, <0 reserved for system use
      !
      ! to call interpolate() directly, the arg list MUST BE:
      !  interpolate(state, location, KIND_xxx, obs_val, istatus)
      !
      ! the preprocess program generates lines like this automatically,
      ! and this matches the interfaces in each model_mod.f90 file.
      !
      ! CASE statements and algorithms for specific observation kinds are
      ! inserted here by the DART preprocess program.

         case(RAW_STATE_1D_INTEGRAL)
            call get_expected_1d_integral_distrib(location, obs_def%key, expected_obs, istatus, state_ens_handle, win)
      case(RAW_STATE_VARIABLE)
         call interpolate_distrib(location, KIND_RAW_STATE_VARIABLE, istatus, expected_obs, state_ens_handle, win)

      ! If the observation kind is not available, it is an error. The DART
      ! preprocess program should provide code for all available kinds.
      case DEFAULT
         call error_handler(E_ERR, 'get_expected_obs_from_def', &
            'Attempt to evaluate or assimilate undefined obs_kind type.', &
             source, revision, revdate)
   end select
else
   ! Not computing forward operator for this kind
   expected_obs = missing_r8
   istatus = 0
endif

end subroutine get_expected_obs_from_def_distrib_state

!----------------------------------------------------------------------------


  subroutine read_obs_def(ifile, obs_def, key, obs_val, fform)
!----------------------------------------------------------------------------
! subroutine read_obs_def(ifile, obs_def, key, obs_val, fform)
!
! ifile
! obs_def
! key
! obs_val    needed if you want to perform operations based on value
! fform
!
! Reads an obs_def from file which is just an integer unit number in the
! current preliminary implementation.

integer,                    intent(in)    :: ifile
type(obs_def_type),         intent(inout) :: obs_def
integer,                    intent(in)    :: key
real(r8),                   intent(inout) :: obs_val
character(len=*), optional, intent(in)    :: fform

character(len=5)  :: header
integer           :: o_index
logical           :: is_ascii
character(len=32) :: fileformat   ! here for backwards compatibility only

if ( .not. module_initialized ) call initialize_module

is_ascii = ascii_file_format(fform)

! here for backwards compatibility only; after the next release,
! remove this and force people in their own obs_def_xxx_mod.f90 code
! to set the last arg to read/write to be fform instead of fileformat
if (is_ascii) then
   fileformat = 'formatted'
else
   fileformat = 'unformatted'
endif

! Begin by reading five character ascii header, then location, kind, error variance, index

! Need to add additional error checks on read
if (is_ascii) then
   read(ifile, '(a5)') header
   if(header /= 'obdef') then
      call error_handler(E_ERR,'read_obs_def', &
         'Expected header "obdef" in input file', source, revision, revdate)
   endif
endif

! Read the location, kind, time and error variance
obs_def%location = read_location(ifile, fform)
if (is_ascii) then
   read(ifile, '(a5)' ) header
   if(header /= 'kind ') then
      call error_handler(E_ERR,'read_kind', &
         'Expected kind header "kind " in input file', &
          source, revision, revdate)
   endif
   read(ifile, *) o_index
else
   read(ifile)    o_index
endif

! Negative value is identity obs, doesn't need mapped
! Positive value must use mapping to get to proper index in obs_kind
if(o_index < 0) then
   obs_def%kind = o_index
else
   obs_def%kind = map_def_index(o_index)
endif

! This kind may have its own module that needs to read more
select case(obs_def%kind)
   ! More complicated kinds may require reading additional information from
   ! an observation sequence file. Case code to do this is inserted here by
   ! the DART preprocess program.

      case(RAW_STATE_1D_INTEGRAL)
         call read_1d_integral(obs_def%key, ifile, fform)
   case(RAW_STATE_VARIABLE)
      continue

! A negative value means identity observations, just move along
   case (:-1)
      continue

   case DEFAULT
      call error_handler(E_ERR, 'read_obs_def', &
         'Attempt to read for undefined obs_kind type.', &
         source, revision, revdate)
end select

! Read the time for the observation
obs_def%time = read_time(ifile, fform)

if (is_ascii) then
   read(ifile, *) obs_def%error_variance
else
   read(ifile)    obs_def%error_variance
endif

end subroutine read_obs_def

!----------------------------------------------------------------------------

subroutine write_obs_def(ifile, obs_def, key, fform)

! Writes an obs_def to file.

integer,                    intent(in) :: ifile
type(obs_def_type),         intent(in) :: obs_def
integer,                    intent(in) :: key
character(len=*), intent(in), optional :: fform

logical           :: is_ascii
character(len=32) :: fileformat   ! here for backwards compatibility only

if ( .not. module_initialized ) call initialize_module

is_ascii = ascii_file_format(fform)

! here for backwards compatibility only; after the next release,
! remove this and force people in their own obs_def_xxx_mod.f90 code
! to set the last arg to read/write to be fform instead of fileformat
if (is_ascii) then
   fileformat = 'formatted'
else
   fileformat = 'unformatted'
endif

! Write the 5 character identifier for verbose formatted output
if (is_ascii) write(ifile, '("obdef")')

! Write out the location, kind and error variance
call write_location(ifile, obs_def%location, fform)
if (is_ascii) then
   write(ifile, '("kind")' )
   write(ifile, *) obs_def%kind
else
   write(ifile)    obs_def%kind
endif

! This kind may have its own module that needs to write more
select case(obs_def%kind)
   ! More complicated kinds may require writing additional information from
   ! an observation sequence file. Case code to do this is inserted here by
   ! the DART preprocess program.

      case(RAW_STATE_1D_INTEGRAL)
         call write_1d_integral(obs_def%key, ifile, fform)
   case(RAW_STATE_VARIABLE)
      continue

   ! A negative value means identity observations, just move along
   case (:-1)
      continue

   case DEFAULT
      call error_handler(E_ERR, 'write_obs_def', &
         'Attempt to write for undefined obs_kind type.', &
         source, revision, revdate)
end select

call write_time(ifile, obs_def%time, fform)

if (is_ascii) then
   write(ifile, *) obs_def%error_variance
else
   write(ifile)    obs_def%error_variance
endif

end subroutine write_obs_def


subroutine interactive_obs_def(obs_def, key)
!---------------------------------------------------------------------------
!
! Allows interactive creation of an observation

type(obs_def_type), intent(inout) :: obs_def
integer,               intent(in) :: key

if ( .not. module_initialized ) call initialize_module

! Get the observation kind WANT A STRING OPTION, TOO?
obs_def%kind = get_kind_from_menu()

! Input any special stuff for this kind
select case(obs_def%kind)
   ! More complicated kinds may require inputting additional information to
   ! define an observation. Case code to do this is inserted here by the
   ! DART preprocess program.

      case(RAW_STATE_1D_INTEGRAL)
         call interactive_1d_integral(obs_def%key)
   case(RAW_STATE_VARIABLE)
      continue

   ! A negative value means identity observations, just move along
   case (:-1)
      continue
   case DEFAULT
      call error_handler(E_ERR, 'interactive_obs_def', &
         'Attempt to interactively create undefined obs_kind type.', &
         source, revision, revdate)
end select

! If the kind is an identity observation, don't need to call location
! Get location from state meta_data
if(obs_def%kind < 0) then
! Get the location of this from model
   call get_state_meta_data(-1 * obs_def%kind, obs_def%location)
else! Get the location
   call interactive_location(obs_def%location)
endif

! Get the time
call interactive_time(obs_def%time)

write(*, *) 'Input error variance for this observation definition '
read(*, *) obs_def%error_variance

! TJH -- might want to do some sort of error checking (i.e. for positive values)

end subroutine interactive_obs_def

!----------------------------------------------------------------

subroutine destroy_obs_def(obs_def)
! TECHNICALLY NEED TO CALL DESTRUCTORS FOR ALL SUBCOMPONENTS,
! NO ALLOCATED STORAGE YET

type(obs_def_type), intent(inout) :: obs_def

if ( .not. module_initialized ) call initialize_module

call set_obs_def_location(obs_def, set_location_missing() )
obs_def%kind = missing_i
call set_obs_def_time(obs_def, set_time_missing() )
call set_obs_def_error_variance( obs_def, missing_r8)

end subroutine destroy_obs_def

!---------------------------------------------------------------------------
!---------------------------------------------------------------------------

end module obs_def_mod

! <next few lines under version control, do not edit>
! $URL: https://proxy.subversion.ucar.edu/DAReS/DART/branches/rma/obs_def/DEFAULT_obs_def_mod.F90 $
! $Id: DEFAULT_obs_def_mod.F90 6256 2013-06-12 16:19:10Z thoar $
! $Revision: 6256 $
! $Date: 2013-06-12 10:19:10 -0600 (Wed, 12 Jun 2013) $
