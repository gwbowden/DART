<HTML>
<HEAD>
<TITLE>DART User Task Help Sheet</TITLE>
<link rel="stylesheet" type="text/css" href="doc.css"></link> 
</HEAD>
<BODY>

<!--==================================================================-->

<br>
<img src = "../../images/Dartboard9.png" alt="snappy DART image"></img>
<br>
<H1>DART User Task Help Sheet</H1>

<P>This documentation is an overview and a pointer to where to find
more detailed documentation on how to accomplish common tasks in DART.
<UL>
<LI>How do I <a href="#OVERVIEW">get started</a> with DART?
<LI>What does DART being a <a href="#TOOLKIT">toolkit</a> mean for me?
<LI>How do I add a <a href="#NEWMOD">new model</a> to DART?
<LI>How do I add a <a href="#NEWOBS">new observation type</a> to DART?
<LI>How do I <a href="#RUNOSSE">run an existing model</a> with
synthetic observations to experiment with
various DART data assimilation options?
<LI>How do I <a href="#RUNME">run an existing model</a> with
real-world observations?
</UL>

<!--==================================================================-->


<A NAME="OVERVIEW"></A>
<H1>DART Overview</H1>

<P>
The Data Assimilation Research Testbed (DART) is designed to facilitate the
combination of assimilation algorithms, models, and <strong>real</strong> (as
well as synthetic) observations to allow increased understanding of all three.
The DART programs have been compiled with many Fortran 90 compilers and run on
linux compute-servers, linux clusters, OSX laptops/desktops, SGI Altix
clusters, supercomputers running AIX ... a pretty broad range, really.
</P>

<P>
DART employs a modular programming approach to apply Kalman Filter algorithms
that move model data closer toward a state that is more consistent with
information from a set of observations. Models may be swapped in and out, as
can different algorithms in the Ensemble Kalman Filter. The method requires
running multiple instances of a model to generate an ensemble of states. A
forward operator appropriate for the type of observation being used is applied
to each of the states to generate the model's estimate of the observation.
Comparing these estimates and their uncertainty to the observation and its
uncertainty ultimately results in the adjustments to the model states.
There's much more to it, described in detail in the tutorial directory of the
package.
</P>

<P>
DART ultimately creates a few netCDF files containing the model states just
before the adjustment (<em class=file>Prior_Diag.nc</em>) and just after the
adjustment (<em class=file>Posterior_Diag.nc</em>) as well as a file <em
class=file>obs_seq.final</em> with the model estimates of the observations.
There is a suite of Matlab&#174; functions that facilitate exploration of the
results, but the netCDF files are inherently portable and contain all the
necessary metadata to interpret the contents.
</P>

<P>
There is a <a href="Jamaica_release.html">full introduction and tutorial</a>
to take you through getting compiled and running.  Start there.
</P>

<!--==================================================================-->
<A NAME="TOOLKIT"></A>
<H1>Why do I care that DART is a Toolkit?</H1>

<P>The Data Assimilation Research Testbed (DART) is designed to 
work with many different models and observation types, without
requiring intrusive changes in the model code, and without requiring
that each model reimplement the same observation handling code.
This is good.
</P>

<P>However, this also means there are certain places in the DART
code where strict lines have to be drawn between different parts
of the software system; where code must obey the rules for
which subroutines can be public, what information can go across
particular boundaries, and how certain modules are structured.
In some cases this makes the code appear to be more complicated
than simply stuffing new lines of fortran directly into an existing
file.  However, it gives you all the good things that intelligent
software engineering can bring (yes, there are other types of
software engineering which just complicate things unnecessarily)
including code reuse, better testing, more general systems, etc.
</P>

<P>In the sections below, there are interfaces that must be
respected when you add a new module or observation type.
This allows the system to remain generic and for others to
reuse the work done by previous DART users.
</P>

<!--==================================================================-->

<A NAME="NEWMOD"></A>
<H1>Adding a new model to DART</H1>

<P>Tutorial section NN describes this process.
</P>

<P>There is a blank model template in the
$DART/models/template directory.  It contains extensive comments and
the required interface subroutines that the DART executables call
and need to be interfaced to your model.  Start there, and also you can
examine other models already in DART.  See if you can find the one which
is closest in form and function to the model you're planning to add.
</P>

<!--==================================================================-->

<A NAME="NEWOBS"></A>
<H1>Adding new observation code to DART</H1>

<P>Tutorial section NN describes this process.
</P>

<P>First, some terminology: in DART, an observation KIND is more generic than
a TYPE.  For example, with temperature observations the generic
KIND_TEMPERAURE is defined, but specific sources or types of temperatures are
defined as dart TYPES of temperature observations: e.g.
RADIOSONDE_TEMPERATURE, AIRCRAFT_TEMPERATURE, etc.  This distinction allows
the code to handle the actual computation of temperatures in a uniform way,
but allows the user to only assimilate specific instances of observations if
desired.  </P>

<H2>Adding a new observation KIND</H2>
<P>
If DART does not already have an appropriate KIND defined in
$DART/obs_kind/DEFAULT_obs_kind_mod.F90, add it to the public
numeric list.  Confirm that this kind
does not already exist, and if you do need to add a kind, it
would be good to notify the DART developers.
</P>  
<P>Note that the
file $DART/obs_kind/obs_kind_mod.f90 is autogenerated by
the 'preprocess' program and *SHOULD NOT* be edited directly.
</P>

<H2>Adding a new observation TYPE</H2>
<P>Examine the files in $DART/obs_def.  Again, as with the
dart kind code, the file $DART/obs_def/obs_def_mod.f90 is
autogenerated by the 'preprocess' program and should not
be edited directly. In general, the DEFAULT_obs_type_mod.F90
does not need to be edited directly; additional observation
type information is added to separate source files and then
added to an autogenerate obs_type_mod.f90 file
by the 'preprocess' program.
</P>

<P>If this observation type can be handled by simple linear
interpolation between grid points, then look at the code 
in either obs_def_1d_state_mod.f90 (for models using the 1D
locations code, like the Lorenz model), or look at
obs_def_eval_mod.f90 or obs_def_pe2lyr_mod.f90 (for models
using the 3D locations code, like most full 3D models).
</P>

<P>If this observation type has additional information that
must be read and written in addition to a single observation
value, then examine the obs_def_radar_mod.f90 for an example
of a more complicated observation type which includes additional
data required to process these observations.
<!-- TODO: Greg L. requested more examples of this... -->
</P>


<H2>Building a new observation type into a model</H2>
<P>The sections in the simplest obs_def_xxx_mod.f90 files are
not full f90 programs or modules; they are code fragments with
specifically formatted comments.  The code fragments will
be added to the obs_def_mod.f90 file by the 'preprocess'
program.
</P>

<P>The 'input.nml' file in each model's work directory
contains namelist items
for each model and will have a section for '&preprocess_nml'.
The item 'input_files' is what controls which of the
obs_def observation types are included at compile-time
in building the assimilation programs for each model.
</P>

<P>At run time, the observation types listed in
the '&obs_kind_nml' namelist section will control which
observation types are assimilated and evaluated.
</P>

<!--==================================================================-->

<A NAME="RUNOSSE"></A>
<H1>DART Running an existing model with synthetic observations</H1>

<P>Tutorial section NN describes this process.
</P>

<P>You can use your model to generate synthetic observations and
then pretend they are what you got from an instrument and test your
code and tune your experiments before you have real data.  You can
also use synthetic observations to decide how many observations you
need, how accurate they need to be, where they need to be, etc. 
This helps in data acquisition system design and is sometimes 
called an OSSE: Observing System Simulation Experiment.
</P>

<P>There are a series of programs to run in order to generate
your synthetic data; the tutorial has a good flowchart on page N 
of section Y.  You will be using the 'create_obs_sequence',
'create_fixed_network_seq', 'perfect_model_obs', and the 'filter'
program in this process.  All of the existing model 'work' directories
have a 'workshop_setup.csh' script which builds all the possible
executables for a particular model and running it is a good place to start.
<P>

<!--==================================================================-->

<A NAME="RUNME"></A>
<H1>DART Running an existing model with real data</H1>

<P>Tutorial section NN describes this process.
</P>

<P>In any large, complicated model, the 'truth' is unknown.  Real
observations have known accuracy limits, unknown errors (instrument error,
human error, processing errors), and the model itself has biases.
The combination of all these sources is what turns scientist's hair grey.
</P>

<P>You will be using a series of programs including 'perfect_model_obs',
and then either 'filter' with different 'input.nml' namelist settings
or a custom program to generate a set of ensembles, and then 'filter'
to do the actual assimilation.
</P>

<!--==================================================================-->
<!--==================================================================-->

<H1>Fine print</H1>

<DIV ALIGN=LEFT class=disclaimer>
GNU General Public License

<P>DART is free software; you can redistribute it and/or modify
it and are expected to follow the terms of the GNU General Public
License as published by the Free Software Foundation. </P>

<P>DART is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details. </P>

<P>You should have received a copy of the GNU General Public License
along with DART; if not, write to:<BR>
Free Software Foundation, Inc.<BR>
59 Temple Place, Suite 330<BR>
Boston, MA  02111-1307  USA<BR>
or see:<BR>
http://www.gnu.org/licenses/gpl.txt
</P>
</DIV>

<!--==================================================================-->

<HR>
<!--#config errmsg="SSI Error" timefmt = "%e %h %Y"-->
<center>
Last modified: <!--#echo var="LAST_MODIFIED" --> 
 &nbsp; by nancy 'at' ucar 'dot' edu
</center>


</BODY>
</HTML> 
